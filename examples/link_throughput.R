# This R script reads the outputs produced by 'link_throughput.py' and produces
# various outputs such as graphs and interesting data frames (tables of data).
#
# To get started, start R (note capital letter...) from the same directory as
# you ran link_throughput.py and type:
#
#     > source("link_throughput.R")   # Note: you can tab-complete files!
#
# Various plots and data frames are generated by sourcing this script. Look
# through the script to find their names and just print them on the interactive
# R shell to make them appear. Try any of the following
#
#     > throughput_histogram
#     > per_direction_throughputs
#     > per_fpga_link_throughputs
#
# Note that the following R libraries are required:
#
# * ggplot2 -- a fantastic plotting library
# * dplyr -- a fantastic data-munging library
#
# If you can, install these with your distribution's package manager, otherwise
# see http://www.r-bloggers.com/installing-r-packages/ for a guide to
# installing packages things in R.
#
# Read on to see how to display the data this script produces!

################################################################################
# A brief R primer as R's syntax is dreadfully odd...
#
# Just like Python and BASH and ..., R uses # to start a comment. But you
# already knew that ;)
#
# Assignment is done via the <- operator, e.g.
#     > a <- 123
#     > a
#     123
#
# When you read in a CSV using read.csv("filename"), you get a dataframe. A
# dataframe is essentially a big table: it has a fixed set of named columns (in
# the case of CSVs, these names are taken from the first line of the CSV file)
# and then a number of rows.
#     > d <- read.csv("totals.csv")
#     > d
#        group_link group_odd_even group time deadlines_missed local_multicast external_multicast dropped_multicast      sent  blocked  received ideal_received
#     1        east              0     0    1             3301       166452346          166452346                 0 166452346 25548038 166452346      166452346
#     2        east              1     1    1             2976       148062126          148062126                 0 148062126 43938258 148062126      148062126
#     3        west              0     2    1             2929       147040104          147040104                 0 147040104 44960280 147040104      147040104
#     4        west              1     3    1             2931       165640470          165640470                 0 165640470 26359914 165640470      165640470
#     5       north              0     4    1             2601       154392690          154392690                 0 154392690 37607694 154392690      154392690
#     6       north              1     5    1             2610       139644180          139644180                68 139644248 52356136 139644180      139644248
#     7       south              0     6    1             3090       149683607          149683607                 0 149683607 42316777 149683607      149683607
#     8       south              1     7    1             3112       164998453          164998453                 0 164998453 27001931 164998453      164998453
#     9  north_east              0     8    1             2969       165094660          165094660                 0 165094660 26905724 165094660      165094660
#     10 north_east              1     9    1             2843       146061778          146061778                 4 146061782 45938602 146061778      146061782
#     11 south_west              0    10    1             2990       147173985          147173985                 0 147173985 44826399 147173985      147173985
#     12 south_west              1    11    1             3208       165380218          165380218                 0 165380218 26620166 165380218      165380218
#
# You can extract a particular column on its own using the $ operator:
#    > d$local_multicast
#    [1] 166452346 148062126 147040104 165640470 154392690 139644180 149683607 164998453 165094660 146061778 147173985 165380218
#
# You can also compute any of the predictable set of basic stats against this
# such as min, max, mean, sd (standard deviation)...
#    > mean(d$local_multicast)
#    [1] 154968718
#
# Throughout this file I use functions from a library called dplyr which is
# used to manipulate large tables of data into more useful forms. See:
# https://cran.rstudio.com/web/packages/dplyr/vignettes/introduction.html
# For a description of what dplyr does though you may be able to guess when you
# see stuff below. Dplyr provides a library of simple functions which given a
# dataframe, do something to it. All very unixy. For example:
#    > filter(d, dropped_multicast != 0)
#      group_link group_odd_even group time deadlines_missed local_multicast external_multicast dropped_multicast      sent  blocked  received ideal_received
#    1      north              1     5    1             2610       139644180          139644180                68 139644248 52356136 139644180      139644248
#    2 north_east              1     9    1             2843       146061778          146061778                 4 146061782 45938602 146061778      146061782
# This filters the table to only include things matching a particular pattern
# (note that dropped_multicast isn't a variable but rather R is treating that
# argument like a symbolic expression). If we combine it with another dplyr
# function:
#    > summarize(filter(d, dropped_multicast != 0), avg_dropped = mean(dropped_multicast))
#      avg_dropped
#    1          36
# Notice that the expression is getting a little hard to read... As a result a
# fancy operator %>% is defined which takes the value on its left and uses it
# as the first argument to the function on its right. For example, the above
# could be written as:
#    > d %>% filter(dropped_multicast != 0) %>% summarize(avg_dropped = mean(dropped_multicast))
#      avg_dropped
#    1          36
# This layout looks rather like a shell pipline and is much easier to read! I
# use this form extensively in this script.
#
# Finally, there's ggplot2, my plotting tool of choice when using R (R's built
# in plotting libraries are OK-ish but ggplot2 can be briliant). the "gg" in
# ggplot2 stands for "Grammar of Graphics" and ggplot2 is based around the
# notion of describing your graph incrementally literally by adding (with the +
# operator!) bits of a plot together. This will become clearer when you get to
# a plot in the script.
################################################################################


# Load the libraries we're going to use
require("ggplot2")
require("dplyr")

# Lets generate a dataframe which lists the throughput for every link in our
# system. Unfortunately, the raw data in 'data.csv', produced by
# 'throughput.py', has the throughputs of each core-to-core stream
# individually. Further, the data is also in the form of a packet count, not
# megabits per second or even packets-per-second.
#
# Step 1: read the data from the CSV...
data <- read.csv("data.csv") %>%
    # Step 2: For each chip in the system we're going to compute the total
    # throughput of each link on each chip. The group_by dplyr function labels
    # the columns we're going to be grouping the data on (on its own, it
    # doesn't actually modify the data, that'll be done in the next step, it
    # just labels those columns as the ones to group the data with).
    group_by(x, y, link, board_x, board_y, fpga_num, fpga_link_num, duration) %>%
    # Step 3: We'll now take each group and summarise all the rows in it into a
    # single row using the summarize dplyr function. We just total up the three
    # metrics of interest.
    summarize( sent=sum(sent)
             , received=sum(received)
             , blocked=sum(blocked)
             ) %>%
    # Step 4: We're now going to create a few new columns to the data frame
    # calculated from the data in each row.
    mutate( # First we calculate the number of dropped packets note that this
            # is not the same thing as the router's dropped_multicast counters
            # but unless something has gone wrong (e.g. my 24-board woes), the
            # values should match exactly.
            dropped=sent-received
            # We convert the received packet count into a throughput in
            # megabits per second (note that the duration column just contains
            # the number of seconds packets were sent for during an
            # experiment).
          , throughput=received * 40 / 1024 / 1024 / duration
            # Finally, we add a boolean indicating if the link goes via an
            # FPGA. The fpga_num column contains the FPGA number used by a link
            # when it crosses a board-to-board boundary. When a link does not
            # cross this boundary, the data contains a NA (not-applicable)
            # which is a special sentinel value in R, a little like None in
            # Python. The is.na function does what you'd expect and produces a
            # boolean.
          , via_fpga= !is.na(fpga_num)
          )

# Now we have a data frame like so:
#    > data
#       x y       link board_x board_y fpga_num fpga_link_num  duration    sent received blocked dropped throughput via_fpga
#    1  0 0       east       0       0       NA            NA 0.3333333 2433601  2433601  233071       0   278.5035    FALSE
#    2  0 0      north       0       0       NA            NA 0.3333333 2233157  2233157  433515       0   255.5645    FALSE
#    3  0 0 north_east       0       0       NA            NA 0.3333333 2410729  2410729  255943       0   275.8860    FALSE
#    4  0 0      south       0       0        0            15 0.3333333  935433   935433 1731239       0   107.0518     TRUE
#    5  0 0 south_west       0       0        1             0 0.3333333  909466   909466 1757206       0   104.0801     TRUE
#    6  0 0       west       0       0        1             1 0.3333333  909464   909464 1757208       0   104.0799     TRUE
#    7  0 1       east       0       1       NA            NA 0.3333333 2421241  2421241  245431       0   277.0890    FALSE
#    8  0 1      north       0       1       NA            NA 0.3333333 2231590  2231590  435082       0   255.3852    FALSE
#    9  0 1 north_east       0       1       NA            NA 0.3333333 2335038  2335038  331634       0   267.2239    FALSE
#    10 0 1      south       0       1       NA            NA 0.3333333 2390689  2390689  275983       0   273.5926    FALSE
#    .. . .        ...     ...     ...      ...           ...       ...     ...      ...     ...     ...        ...      ...
#
# From this we can produce some fun stats straight off the bat
#    > mean(data$throughput)
#    [1] 246.3161


# Now lets plot a histogram of throughputs using ggplot.
throughput_histogram <- ( # We start off by creating a ggplot object with our
                          # data frame. The aes (aesthetics) argument tells
                          # ggplot what parts of our data will be plotted and
                          # how. In this case on the x-axis we're going to have
                          # the throughput and using fill-colour we'll
                          # represent whether the data is for an FPGA-link or
                          # not.
                          ggplot(data, aes(x=throughput, fill=via_fpga))
                          # Now we've specified the data we specify how to draw
                          # it. In this case we tell it to draw the data as a
                          # histogram and we bin the data into 1 MBit/s bins.
                        + geom_histogram(binwidth=1.0)
                          # (optional) We define axis labels. If we didn't
                          # specify this, the X-axis just gets labeled
                          # "throughput" automatically but by manually
                          # providing a label we can include the units!
                        + labs( x="Throughput (MBit/s)"
                              , title="Histogram of link throughputs in SpiNNaker"
                              )
                        )
# To make the plot appear, simply print the variable it was assigned to:
#    > throughput_histogram

# Next lets plot the average throughputs for all link directions.
per_direction_throughputs <- ( ggplot( # We must modify our data first using
                                       # dplyr to compute the per-link
                                       # averages (excluding FPGA links).
                                       data %>%
                                           filter(via_fpga==FALSE) %>%
                                           group_by(link) %>%
                                           summarize( min_throughput=min(throughput)
                                                    , max_throughput=max(throughput)
                                                    , mean_throughput=mean(throughput)
                                                    )
                                     , aes( x=link,
                                          , y=mean_throughput
                                          , ymin=min_throughput
                                          , ymax=max_throughput
                                          ))
                               # The stat="identity" bit makes this a normal
                               # bar chart and is a wart in ggplot's API.
                             + geom_bar(stat="identity")
                             + geom_errorbar()
                             + labs( y="Mean throughput (MBit/s), errorbars = min/max"
                                   , title="Per-link-direction throughput breakdown (excl. FPGA links)."
                                   )
                             )
# To make the plot appear, simply print the variable it was assigned to:
#    > per_direction_throughputs

# Now lets plot the per FPGA link averages.
per_fpga_link_throughputs <- ( ggplot( # We must modify our data first using
                                       # dplyr to compute the per-FPGA-link
                                       # averages
                                       data %>%
                                           filter(via_fpga==TRUE) %>%
                                           group_by(fpga_num, fpga_link_num) %>%
                                           summarize( min_throughput=min(throughput)
                                                    , max_throughput=max(throughput)
                                                    , mean_throughput=mean(throughput)
                                                    )
                                     , aes( x=fpga_link_num,
                                          , y=mean_throughput
                                          , ymin=min_throughput
                                          , ymax=max_throughput
                                          ))
                             + geom_bar(stat="identity")
                             + geom_errorbar()
                               # This produces multiple plots, one for each
                               # fpga_num value.
                             + facet_grid(fpga_num ~ .)
                             + labs( y="Mean throughput (MBit/s), errorbars = min/max"
                                   , x="FPGA-SpiNNaker Link Number"
                                   , title="Per-FPGA-link-direction throughput breakdown."
                                   )
                             )
# To make the plot appear, simply print the variable it was assigned to:
#    > per_fpga_link_throughputs
